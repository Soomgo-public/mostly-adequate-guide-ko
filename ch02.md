# Chapter 02: 일급 함수 (First Class Functions)

## 훑어보기

우리가 함수를 "일급"이라고 부를 때는, 함수가 다른 것들과 같다는 걸 강조하고자 함입니다... 여기에서 '다른 것'은 일반 클래스라고 보면 됩니다. 우리는 함수를 여느 데이터 타입처럼 다룰 수 있어요. 전혀 특별할 게 없습니다. 이것들은 배열에 담길 수도 있고, 함수 인자로 전달될 수도, 변수에 할당될 수도 있습니다.

이건 JavaScript 기초지식이지만 이렇게 언급하는 이유는, Github에 올라오는 코드들만 잠깐 살펴봐도 사람들이 이 개념에 대해서 단체로 무시하거나 집단 망각을 한것처럼 보이기 때문입니다. 가상의 예를 들어볼까요? 그럽시다.

```js
const hi = name => `Hi ${name}`;
const greeting = name => hi(name);
```

여기에서 `hi`를 에워싸고 있는 함수 래퍼 `greeting`은 완전히 불필요합니다. 왜그럴까요? 왜냐하면 JavaScript에서 함수들은 *callable* 이기 때문입니다. 만약 `hi`의 끝에 `()`가 붙어있다면 실행되고 실행결과를 반환할거에요. 그렇지 않은 경우에는 단순히 변수에 저장되어있던 함수를 반환할 겁니다. 분명히 하기 위해서 예제로 보여드릴게요:

```js
hi; // name => `Hi ${name}`
hi("jonas"); // "Hi jonas"
```

`greeting`이 그저 `hi`를 완전히 동일한 인자를 갖고 호출하는 것에 지나지 않기 때문에, 우리는 이렇게 단순화시킬 수 있습니다:

```js
const greeting = hi;
greeting("times"); // "Hi times"
```

다시 말해서, `hi`는 이미 하나의 인자만을 기대하는 함수인데 왜 단순히 `hi`를 완전히 동일한 인자로 호출하는 또다른 함수를 만들어야 할까요? 이건 정말 말도 안되는 일이에요. 마치 무더운 7월의 끝자락에 바람을 막기위해 두꺼운 파카를 껴입고 아이스크림을 먹는 것과 같습니다.

이건 불쾌하게 장황할 뿐 아니라, 함수를 둘러싼 함수는 평가를 지연시킬 뿐입니다.(왜 그런지는 나중에 살펴보겠습니다)

계속 나아가기 전에 이 개념을 단단히 이해하는것이 정말 중요하기때문에, 어느 npm 패키지에서 발굴해낸 몇가지 재미있는 예제를 통해 탐구해보겠습니다:

```js
// 흠..
const getServerStuff = callback => ajaxCall(json => callback(json));

// 똑똑
const getServerStuff = ajaxCall;
```

세상이 이렇게 ajax 코드로 오염되어있습니다. 여기에서 왜 둘이 동등한지를 보여줄게요:

```js
// 이 라인이
ajaxCall(json => callback(json));

// 이 라인과 동일합니다
ajaxCall(callback);

// 그러니 일단 getServerStuff 를 한번 리팩토링 하고 
const getServerStuff = callback => ajaxCall(callback);

// 한번 더 리팩토링 합니다
const getServerStuff = ajaxCall; // <-- 보세요, ()가 없죠
```

자 제군들, 이런일이 벌어진거였어요. 제가 왜 이렇게 끈질긴지를 이해시켜드리기 위해 한 가지 더 살펴볼게요.

```js
const BlogController = {
  index(posts) { return Views.index(posts); },
  show(post) { return Views.show(post); },
  create(attrs) { return Db.create(attrs); },
  update(post, attrs) { return Db.update(post, attrs); },
  destroy(post) { return Db.destroy(post); },
};
```

이 웃기는 컨트롤러는 굉장히 부풀려져있어요. 우리는 이렇게 재작성할 수 있습니다:

```js
const BlogController = {
  index: Views.index,
  show: Views.show,
  create: Db.create,
  update: Db.update,
  destroy: Db.destroy,
};
```

...또는 View 와 DB을 묶어주는 역할외에는 하는 것이 없으므로 아예 폐기하는 것도 방법입니다.

## 왜 일급을 선호하나요?

Okay, let's get down to the reasons to favor first class functions. As we saw in the `getServerStuff` and `BlogController` examples, it's easy to add layers of indirection that provide no added value and only increase the amount of redundant code to maintain and search through.

In addition, if such a needlessly wrapped function must be changed, we must also need to change our wrapper function as well.

```js
httpGet('/post/2', json => renderPost(json));
```

If `httpGet` were to change to send a possible `err`, we would need to go back and change the "glue".

```js
// go back to every httpGet call in the application and explicitly pass err along.
httpGet('/post/2', (json, err) => renderPost(json, err));
```

Had we written it as a first class function, much less would need to change:

```js
// renderPost is called from within httpGet with however many arguments it wants
httpGet('/post/2', renderPost);
```

Besides the removal of unnecessary functions, we must name and reference arguments. Names are a bit of an issue, you see. We have potential misnomers - especially as the codebase ages and requirements change.

Having multiple names for the same concept is a common source of confusion in projects. There is also the issue of generic code. For instance, these two functions do exactly the same thing, but one feels infinitely more general and reusable:

```js
// specific to our current blog
const validArticles = articles =>
  articles.filter(article => article !== null && article !== undefined),

// vastly more relevant for future projects
const compact = xs => xs.filter(x => x !== null && x !== undefined);
```

By using specific naming, we've seemingly tied ourselves to specific data (in this case `articles`). This happens quite a bit and is a source of much reinvention.

I must mention that, just like with Object-Oriented code, you must be aware of `this` coming to bite you in the jugular. If an underlying function uses `this` and we call it first class, we are subject to this leaky abstraction's wrath.

```js
const fs = require('fs');

// scary
fs.readFile('freaky_friday.txt', Db.save);

// less so
fs.readFile('freaky_friday.txt', Db.save.bind(Db));
```

Having been bound to itself, the `Db` is free to access its prototypical garbage code. I avoid using `this` like a dirty nappy. There's really no need when writing functional code. However, when interfacing with other libraries, you might have to acquiesce to the mad world around us.

Some will argue that `this` is necessary for optimizing speed. If you are the micro-optimization sort, please close this book. If you cannot get your money back, perhaps you can exchange it for something more fiddly.

And with that, we're ready to move on.

[Chapter 03: Pure Happiness with Pure Functions](ch03.md)
