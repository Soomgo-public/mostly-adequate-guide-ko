# Chapter 01: 그래서 우린 대체 뭘 할건가요?

## 소개하기

안녕하세요! 저는 프랭클린 프리스비 교수입니다. 만나서 반갑습니다. 함수형 프로그래밍에 대해 조금 가르쳐 드릴 예정이므로 함께 시간을 보내도록 해보겠습니다. 이제 저에 대해서는 충분한 것 같은데, 당신은 어떤가요? 저는 당신이 최소한 JavaScript 언어에 익숙하고, 약간의 객체 지향 경험이 있고, 스스로 노동계급 프로그래머라고 생각하기를 바랍니다. 곤충학 박사 학위가 없어도 몇몇 버그를 찾아 죽이는 방법만 알면 됩니다.

저는 당신이 함수형 프로그래밍 지식을 가지고 있다고 기대하지 않을 겁니다. 왜냐하면 우리 둘 다 이런 가정을 가졌을 때 어떤 일이 일어나는지 알고 있기 때문입니다. 그러나 아마 당신은 가변 상태, 제한되지 않은 사이드 이펙트 및 원칙 없는 설계를 가지고 작업할 때 불편한 상황을 맞닥드리게 될 겁니다. 이제 제대로 소개했으니 계속 진행해 보겠습니다.

이 장의 목적은 우리가 함수형 프로그램을 작성할 때 무엇을 추구하는지에 대한 느낌을 주는 것입니다. 다음 장을 이해할 수 있으려면 프로그램을 *함수형*하게 만드는 것에 대한 이해가 있어야 합니다. 그렇지 않으면 우리는 목적 없이 낙서를 하고 온힘을 다해 객체를 피하게 될 것입니다 - 참으로 서투른 노력이 아닐 수 없습니다. 우리는 코드를 던질 수 있는 명확한 과녁이 필요하고 물이 거칠어질 때를 위한 최고의 나침반이 필요합니다.

일반적인 프로그래밍 원칙이 몇 가지 있습니다. 어느 프로그램의 깊은 암흑같은 터널로부터 우리를 빛으로 안내하는 다양한 두문자어 신조들이죠: DRY(반복하지 마세요), YAGNI(필요하지 않을 거에요), 느슨한 결합과 높은 응집력, 놀람 최소화 원칙, 단일 책임 원칙 등.

몇 년 동안 들었던 가이드라인을 일일이 나열해서 당신을 힘들게 하지는 않을게요. 요점은 이 가이드라인들이 비록 우리의 궁극적인 목표에는 걸쳐 있을 뿐이지만, 함수적으로 설정되어 있다는 점입니다. 더 진도를 나가기 전에 이쯤에서, 여러분이 우리의 함수형 무릉도원을 위해 키보드를 두드리게될 것이란걸 느끼셨으면 좋겠습니다.

<!--BREAK-->

## 간단하게 만나보기

약간의 광기로 시작합시다. 여기 갈매기 프로그램이 있어요. 무리가 결합하면 더 큰 무리가 되고 번식하면 함께 번식하는 갈매기의 수가 증가합니다. 이 코드는 좋은 객체 지향적인 코드를 의도한 것이 아니고, 현대적인 할당 기반 접근법의 위험을 강조하기 위한 것입니다. 보기:

```js
class Flock {
  constructor(n) {
    this.seagulls = n;
  }

  conjoin(other) {
    this.seagulls += other.seagulls;
    return this;
  }

  breed(other) {
    this.seagulls = this.seagulls * other.seagulls;
    return this;
  }
}

const flockA = new Flock(4);
const flockB = new Flock(2);
const flockC = new Flock(0);
const result = flockA
  .conjoin(flockC)
  .breed(flockB)
  .conjoin(flockA.breed(flockB))
  .seagulls;
// 32
```

도대체 누가 이런 끔찍하고 혐오스러운 것을 만들었을까요? 변화하는 내부 상태를 추적하는 것은 비합리적으로 어렵습니다. 그리고 세상에, 심지어 결과까지 틀렸네요! `16` 이어야 했지만, `flockA`는 작업 도중에 영구적으로 변경되었습니다. 가여운 `flockA`. 이건 IT의 무정부상태이고! 야생동물 산수입니다!

당신이 이 프로그램을 이해하지 못했다고 할지라도 괜찮습니다. 저도 마찬가지거든요. 여기서 기억해야 할 점은 상태 및 변경 가능한 값은 이러한 작은 예제에서도 따라가기 어렵다는 것입니다.

이번에는 좀 더 함수형 접근방식을 사용하여 다시 시도해보겠습니다:

```js
const conjoin = (flockX, flockY) => flockX + flockY;
const breed = (flockX, flockY) => flockX * flockY;

const flockA = 4;
const flockB = 2;
const flockC = 0;
const result =
    conjoin(breed(flockB, conjoin(flockA, flockC)), breed(flockA, flockB));
// 16
```

자, 이번에는 우리가 정답을 맞혔습니다. 훨씬 적은 코드로요. 함수 중첩은 약간 혼란스럽네요...(이건 5장에서 개선해 볼게요). 나아지긴 했지만 조금 더 깊이 파헤쳐 보겠습니다. 스페이드를 스페이드라고 부를때 얻을 수 있는 이득이 분명히 있습니다. 사용자 정의 함수를 더 자세히 조사했다면 단순한 덧셈(`conjoin`)과 곱셈(`breed`)으로 작업하고 있음을 발견했을 것입니다.

이 두 함수는 이름말고는 특별할 것이 없습니다. 사용자 정의 함수의 이름을 'multiply' 및 'add'로 변경하여 그들의 실체를 드러내 보겠습니다.

```js
const add = (x, y) => x + y;
const multiply = (x, y) => x * y;

const flockA = 4;
const flockB = 2;
const flockC = 0;
const result =
    add(multiply(flockB, add(flockA, flockC)), multiply(flockA, flockB));
// 16
```
이렇게 함으로서 우리는 진리를 깨우칩니다:

```js
// 결합법칙 (associative)
add(add(x, y), z) === add(x, add(y, z));

// 교환법칙 (commutative)
add(x, y) === add(y, x);

// 항등원 (identity)
add(x, 0) === x;

// 분배법칙 (distributive)
multiply(x, add(y,z)) === add(multiply(x, y), multiply(x, z));
```

네, 그 오래된 충실한 수학적 속성이 유용해야합니다. 당신이 머리 꼭대기에서 그들을 알지 못했다고 걱정하지 마십시오. 우리 중 많은 사람들에게 이러한 산술 법칙에 대해 배운 지 오래되었습니다. 작은 갈매기 프로그램을 단순화하기 위해 이러한 속성을 사용할 수 있는지 봅시다.

Ah yes, those old faithful mathematical properties should come in handy. Don't worry if you didn't know them right off the top of your head. For a lot of us, it's been a while since we learned about these laws of arithmetic. Let's see if we can use these properties to simplify our little seagull program.

```js
// Original line
add(multiply(flockB, add(flockA, flockC)), multiply(flockA, flockB));

// Apply the identity property to remove the extra add
// (add(flockA, flockC) == flockA)
add(multiply(flockB, flockA), multiply(flockA, flockB));

// Apply distributive property to achieve our result
multiply(flockB, add(flockA, flockA));
```

Brilliant! We didn't have to write a lick of custom code other than our calling function. We include `add` and `multiply` definitions here for completeness, but there is really no need to write them - we surely have an `add` and `multiply` provided by some existing library.

You may be thinking "how very strawman of you to put such a mathy example up front". Or "real programs are not this simple and cannot be reasoned about in such a way." I've chosen this example because most of us already know about addition and multiplication, so it's easy to see how math is very useful for us here.

Don't despair - throughout this book, we'll sprinkle in some category theory, set theory, and lambda calculus and write real world examples that achieve the same elegant simplicity and results as our flock of seagulls example. You needn't be a mathematician either. It will feel natural and easy, just like you were using a "normal" framework or API.

It may come as a surprise to hear that we can write full, everyday applications along the lines of the functional analog above. Programs that have sound properties. Programs that are terse, yet easy to reason about. Programs that don't reinvent the wheel at every turn. Lawlessness is good if you're a criminal, but in this book, we'll want to acknowledge and obey the laws of math.

We'll want to use a theory where every piece tends to fit together so politely. We'll want to represent our specific problem in terms of generic, composable bits and then exploit their properties for our own selfish benefit. It will take a bit more discipline than the "anything goes" approach of imperative programming (we'll go over the precise definition of "imperative" later in the book, but for now consider it anything other than functional programming). The payoff of working within a principled, mathematical framework will truly astound you.

We've seen a flicker of our functional northern star, but there are a few concrete concepts to grasp before we can really begin our journey.

[Chapter 02: First Class Functions](ch02.md)
